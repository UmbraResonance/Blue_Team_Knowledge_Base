# PowerShell Get-WinEvent Hunting Syntax

> **Focus:** Syntax templates for native Windows Event Log analysis.
> **Use Case:** Building high-performance queries for Live Response or Offline Forensics.
> **Legend:** Replace values inside `<...>` with your specific requirements.

---

## 1. Core Filtering Syntax (FilterHashtable)

*Standard structure for high-performance server-side filtering. Always prefer this over `Where-Object` for initial selection.*

```powershell
Get-WinEvent -FilterHashtable @{
    LogName   = '<LOG_NAME>';
    ID        = <EVENT_ID>;
    Level     = <1-5>; # 1:Critical, 2:Error, 3:Warning, 4:Information
    StartTime = (Get-Date).AddHours(-<HOURS>);
} -ErrorAction SilentlyContinue
# Example LogNames: Security, System, Application, Microsoft-Windows-Sysmon/Operational
```

*Use these exact names in the `LogName` parameter. Do not use abbreviations.*

| Common Name | Exact LogName (Copy this) | Description |
| :--- | :--- | :--- |
| **Security** | `'Security'` | Authentication, Process Creation (4688), and Audit Policy changes. |
| **System** | `'System'` | Service Control Manager (SCM), Reboots, and Driver loads. |
| **Application** | `'Application'` | General application errors and crashes. |
| **Sysmon** | `'Microsoft-Windows-Sysmon/Operational'` | Advanced telemetry (Process lineage, Network, DNS). |
| **PowerShell** | `'Microsoft-Windows-PowerShell/Operational'` | Modern PowerShell logs (Script Block logging, Module loads). |
| **PS (Legacy)** | `'Windows PowerShell'` | Older PowerShell engine logs (Pre-PS v5). |
| **Defender** | `'Microsoft-Windows-Windows Defender/Operational'`| Windows Defender Antivirus detections and scans. |

*Or use the following command to find the LogName alernatively*
```powershell
Get-WinEvent -ListLog *<Keyword>* | Select-Object LogName
```

---

## 2. String & Pattern Hunting (Client-Side)

Use this method only as a last resort when the required data is not indexed in structured XML tags (e.g., specific strings buried in the Message field).

[!WARNING] Performance Impact: This is a Client-Side Filtering operation. PowerShell must retrieve and process the full event objects in memory before filtering. Never run these commands on high-volume logs (like Security or Sysmon) without strictly limiting the scope via StartTime or -MaxEvents.

### Keyword Search (Message Field)

```powershell
Get-WinEvent -FilterHashtable @{LogName='<LOG_NAME>'; StartTime=(Get-Date).AddDays(-<DAYS>)} | 
Where-Object { $_.Message -like "*<KEYWORD>*" } | 
Select-Object TimeCreated, Id, Message
```

### Multiple Keyword Logic

```powershell
Get-WinEvent -FilterHashtable @{LogName='<LOG_NAME>'; ID=<EVENT_ID>} | 
Where-Object { $_.Message -like "*<KEYWORD_1>*" -or $_.Message -like "*<KEYWORD_2>*" }
```

---

## 3. Legacy: Filtering by Property Index (Quick Triage Only)

> [!CAUTION]
> **Fragility Warning:** Property indexes (e.g., `Properties[8]`) may shift between different Windows versions or patch levels. Additionally, this is **Client-Side Filtering**, which performs poorly on large-scale logs. Use only for quick interactive triage, not for formal forensic automation.

```powershell
# Template: Filtering based on property index
Get-WinEvent -FilterHashtable @{LogName='<LOG_NAME>'; ID=<EVENT_ID>} | 
Where-Object { $_.Properties[<INDEX>].Value -eq <VALUE> }

# Common indexes for Event 4624:
# [8]  = Logon Type (e.g., 2, 3, 10)
# [5]  = Account Name
# [18] = Source IP Address
```

### Index Discovery

*If unsure of the property index ID, run this discovery command first:*

```powershell
$Event = Get-WinEvent -LogName <LOG_NAME> -Id <EVENT_ID> -MaxEvents 1
for ($i=0; $i -lt $Event.Properties.Count; $i++) {
    [PSCustomObject]@{
        Index = $i
        Value = $Event.Properties[$i].Value
    }
}
```

---

## 4. Offline Log Analysis (.evtx)

*Syntax for analyzing exported log files from other systems.*

### Parse Single EVTX File

```powershell
Get-WinEvent -Path "<PATH_TO_EVTX_FILE>" | 
Select-Object TimeCreated, Id, Message -First <NUMBER>
```

### Bulk Search in Directory

*Crucial for DFIR: Appends the source filename to each event so you know exactly which artifact provided the evidence.*

```powershell
Get-ChildItem "<DIRECTORY_PATH>\*.evtx" | ForEach-Object {
    $CurrentFile = $_.Name
    Get-WinEvent -Path $_.FullName -FilterXPath "*[System[(EventID=<EVENT_ID>)]]" -ErrorAction SilentlyContinue | 
    Select-Object @{Name='SourceFile'; Expression={$CurrentFile}}, TimeCreated, Id, MachineName, Message
} | Export-Csv "Forensic_Export.csv" -NoTypeInformation
```

### Offline Deep XML Parsing

*Combining Section 4 logic with offline files to extract hidden IOCs from forensic images.*

```powershell
$EvtxPath = "<PATH_TO_EVTX>"
Get-WinEvent -Path $EvtxPath -FilterHashtable @{ID=<EVENT_ID>} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    $eventData = $xml.Event.EventData.Data
    [PSCustomObject]@{
        Time          = $_.TimeCreated
        # Extract specific forensic artifacts
        TargetField   = $eventData | Where-Object {$_.Name -eq "<DATA_NAME>"} | Select-Object -ExpandProperty '#text'
    }
}
```

---

## 5. XML Data Extraction (Advanced)

### Advanced XML Data Extraction Framework

*Use Case: High-performance hunting when target telemetry exists within the non-indexed EventData or UserData fields of any Windows Event.*

```powershell
# Optimized Template for Filtering and Deep Parsing
Get-WinEvent -FilterHashtable @{
    LogName = '<LOG_NAME>' # e.g., 'Microsoft-Windows-Sysmon/Operational'
    ID      = <EVENT_ID>
} -ErrorAction SilentlyContinue | ForEach-Object {
    # 1. Convert to XML for deep access
    $xml = [xml]$_.ToXml()
    $eventData = $xml.Event.EventData.Data
    
    # 2. Create custom object with streamlined property mapping
    [PSCustomObject]@{
        Timestamp     = $_.TimeCreated
        EventID       = $_.Id
        MachineName   = $_.MachineName
        # Generic pattern to extract value by attribute name
        ProcessGuid   = $eventData | Where-Object {$_.Name -eq "ProcessGuid"} | Select-Object -ExpandProperty '#text'
        TargetDetail  = $eventData | Where-Object {$_.Name -eq "<XML_FIELD_NAME>"} | Select-Object -ExpandProperty '#text'
    }
} | Where-Object { $_.TargetDetail -like "*<IOC_PATTERN>*" }
```
**Why This Framework?**
* Server-Side Efficiency: Leverages FilterHashtable to minimize the data retrieved from the log provider.
* Memory Friendly: Uses the PowerShell pipeline to process events one-by-one instead of loading them all into a variable.
* Precise Filtering: Allows you to filter by values that are normally "hidden" inside the message field.

---

## 6. Advanced XPath Filtering (FilterXml)

*Use Case: Performing complex logical operations (AND/OR) on EventData fields at the provider level. Essential for high-volume logs where FilterHashtable's simple key-value matching is insufficient.*

### Multi-Condition Template
```powershell
# Define the XPath query as a Here-String
$XPathQuery = @"
<QueryList>
  <Query Id="0">
    <Select Path="<LOG_NAME>">
      *[System[(EventID=<EVENT_ID>)]] 
      and (
        *[EventData[Data='<VALUE_1>']] 
        or 
        *[EventData[Data='<VALUE_2>']]
      )
    </Select>
  </Query>
</QueryList>
"@

# Execute the search
Get-WinEvent -FilterXml $XPathQuery -ErrorAction SilentlyContinue | ForEach-Object {
    # Custom output formatting
    Write-Host "--- Event Detected ---"
    Write-Host $_.Message "`n"
}
```
**Key Benefits:**
* Server-Side OR Logic: FilterHashtable cannot handle OR conditions for data fields. XPath allows you to look for multiple Indicators of Compromise (IOCs) in a single pass.
* Extreme Precision: By filtering inside the EventData array before the data hits your memory, you drastically reduce the processing overhead on your hunting workstation.

### Specific Attribute Filtering
```powershell
$Log = 'Microsoft-Windows-Sysmon/Operational'
$XPath = "*[EventData[Data[@Name='Image']='<PROCESS_PATH>']] and *[EventData[Data[@Name='CommandLine']='<EXACT_COMMAND_LINE>']]"

Get-WinEvent -LogName $Log -FilterXPath $XPath | 
Select-Object TimeCreated, Id, Message | 
Format-Table -AutoSize
```
---

## 7. Query Selection Guide (Decision Matrix)

| Method | Key Parameter | Best For | Performance | Logic Level |
| :--- | :--- | :--- | :--- | :--- |
| **Basic Filtering** | `-FilterHashtable` | Initial triage by ID, Time, or Level. | **Highest** | Low |
| **Precise Hunting** | `-FilterXPath` | Exact match for command lines or image paths. | **High** | Medium |
| **Complex TTPs** | `-FilterXml` | Advanced logic (OR/AND) within EventData. | **High** | **Highest** |
| **Deep Analysis** | `ForEach + [xml]` | Data extraction for CSV/Reporting or Pivoting. | Medium | **Highest** |

**The Golden Rule:**
1. Use **FilterHashtable** for metadata (Who, When, What ID).
2. Use **XPath/Xml** for content (What DLL, What Command, What IP) in noisy logs.
3. Use **XML Parsing** only after narrowing down the result set to a manageable size.

---

## 8. GUI & Output Formatting

*Helpers for visualization.*

### Interactive Grid View

```powershell
<QUERY_COMMAND> | Select-Object TimeCreated, Id, LevelDisplayName, Message | Out-GridView
```

### Export to CSV

```powershell
<QUERY_COMMAND> | Select-Object * | Export-Csv "<OUTPUT_PATH>.csv" -NoTypeInformation
```

