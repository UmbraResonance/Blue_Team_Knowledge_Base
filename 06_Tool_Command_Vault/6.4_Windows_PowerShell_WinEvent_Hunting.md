# PowerShell Get-WinEvent Hunting Syntax

> **Focus:** Syntax templates for native Windows Event Log analysis.
> **Use Case:** Building high-performance queries for Live Response or Offline Forensics.
> **Legend:** Replace values inside `<...>` with your specific requirements.

---

## 1. Core Filtering Syntax (FilterHashtable)

*Standard structure for high-performance server-side filtering. Always prefer this over `Where-Object` for initial selection.*

### Basic Event ID Filter

```powershell
Get-WinEvent -FilterHashtable @{
    LogName = '<LOG_NAME>'
    ID      = <EVENT_ID>
}
# Example LogNames: Security, System, Application, Microsoft-Windows-Sysmon/Operational
```

*Use these exact names in the `LogName` parameter. Do not use abbreviations.*

| Common Name | Exact LogName (Copy this) | Description |
| :--- | :--- | :--- |
| **Security** | `'Security'` | Authentication, Process Creation (4688), and Audit Policy changes. |
| **System** | `'System'` | Service Control Manager (SCM), Reboots, and Driver loads. |
| **Application** | `'Application'` | General application errors and crashes. |
| **Sysmon** | `'Microsoft-Windows-Sysmon/Operational'` | Advanced telemetry (Process lineage, Network, DNS). |
| **PowerShell** | `'Microsoft-Windows-PowerShell/Operational'` | Modern PowerShell logs (Script Block logging, Module loads). |
| **PS (Legacy)** | `'Windows PowerShell'` | Older PowerShell engine logs (Pre-PS v5). |
| **Defender** | `'Microsoft-Windows-Windows Defender/Operational'`| Windows Defender Antivirus detections and scans. |

*Or use the following command to find the LogName alernatively*
```powershell
Get-WinEvent -ListLog *<Keyword>* | Select-Object LogName
```

### Time-Based Filter

*Query logs within a specific recent timeframe.*

```powershell
Get-WinEvent -FilterHashtable @{
    LogName   = '<LOG_NAME>'
    StartTime = (Get-Date).AddHours(-<HOURS>)
}
```

*Query logs within a defined timeframe with absolute time range*

```powershell
Get-WinEvent -FilterHashtable @{
    LogName   = '<LOG_NAME>'
    StartTime = "YYYY-MM-DD HH:MM:SS"
    EndTime   = "YYYY-MM-DD HH:MM:SS"
    # Time used here is local machine's time, sometimes you need to convert it from UTC time.
}
```

### Combined Filter (ID + Time)

*The most common hunting pattern.*

```powershell
Get-WinEvent -FilterHashtable @{
    LogName   = '<LOG_NAME>'
    ID        = <EVENT_ID>
    StartTime = (Get-Date).AddMinutes(-<MINUTES>)
} | Select-Object TimeCreated, Id, Message | Format-Table -AutoSize
```

### Filtering by Specific Property (e.g., Logon Type)

*Filter based on indexed properties (Data field) inside the event.*

```powershell
Get-WinEvent -FilterHashtable @{LogName='<LOG_NAME>'; ID=<EVENT_ID>} | 
Where-Object { $_.Properties[<INDEX>].Value -eq <VALUE> }
# Common Indexes for Event 4624:
# [8] = Logon Type (e.g., 2, 3, 10)
# [5] = Account Name
# [18] = Source IP Address
```
*Discover property index ID with the following command*

```powershell
$Event = Get-WinEvent -LogName Security -Id <EVENT_ID> -MaxEvents 1
for ($i=0; $i -lt $Event.Properties.Count; $i++) {
    [PSCustomObject]@{
        Index = $i
        Value = $Event.Properties[$i].Value
    }
}
```

---

## 2. String & Pattern Hunting (Client-Side)

*Use when searching for non-indexed data (keywords, filenames, command lines) within the Message field.*

### Keyword Search (Message Field)

```powershell
Get-WinEvent -FilterHashtable @{LogName='<LOG_NAME>'; StartTime=(Get-Date).AddDays(-<DAYS>)} | 
Where-Object { $_.Message -like "*<KEYWORD>*" } | 
Select-Object TimeCreated, Id, Message
```

### Multiple Keyword Logic

```powershell
Get-WinEvent -FilterHashtable @{LogName='<LOG_NAME>'; ID=<EVENT_ID>} | 
Where-Object { $_.Message -like "*<KEYWORD_1>*" -or $_.Message -like "*<KEYWORD_2>*" }
```

---

## 3. Offline Log Analysis (.evtx)

*Syntax for analyzing exported log files from other systems.*

### Parse Single EVTX File

```powershell
Get-WinEvent -Path "<PATH_TO_EVTX_FILE>" | 
Select-Object TimeCreated, Id, Message -First <NUMBER>
```

### Bulk Search in Directory

*Recursively search all .evtx files in a folder for a specific Event ID.*

```powershell
Get-ChildItem "<DIRECTORY_PATH>\*.evtx" | ForEach-Object {
    Get-WinEvent -Path $_.FullName -FilterXPath "*[System[(EventID=<EVENT_ID>)]]" -ErrorAction SilentlyContinue
} | Select-Object TimeCreated, Id, Message
```

---

## 4. XML Data Extraction (Advanced)

### Advanced XML Data Extraction Framework

*Use Case: High-performance hunting when target telemetry exists within the non-indexed EventData or UserData fields of any Windows Event.*

```powershell
---

## 4. Advanced XML Data Extraction Framework (Updated)

*Use Case: High-performance hunting when target telemetry exists within non-indexed fields (e.g., Sysmon network targets, Defender detection details).*

```powershell
# Optimized Template for Filtering and Deep Parsing
Get-WinEvent -FilterHashtable @{
    LogName = '<LOG_NAME>'      # e.g., 'Microsoft-Windows-Sysmon/Operational'
    ID      = <EVENT_ID>        # e.g., 3 (Network), 1 (Process)
    # StartTime = (Get-Date).AddHours(-2) 
} | ForEach-Object {
    # 1. Convert to XML for access to nested Data fields
    $xml = [xml]$_.ToXml()
    $eventData = $xml.Event.EventData.Data
    
    # 2. Create custom object with streamlined property mapping
    New-Object PSObject -Property @{
        Time          = $_.TimeCreated
        Id            = $_.Id
        <FIELD_NAME_1> = $eventData | Where-Object {$_.Name -eq "<XML_ATTRIBUTE_1>"} | Select-Object -ExpandProperty '#text'
        <FIELD_NAME_2> = $eventData | Where-Object {$_.Name -eq "<XML_ATTRIBUTE_2>"} | Select-Object -ExpandProperty '#text'
    }
} | Where-Object { $_.<FIELD_NAME_1> -like "*<IOC_PATTERN>*" }
```
**Why This Framework?**
* Server-Side Efficiency: Leverages FilterHashtable to minimize the data retrieved from the log provider.
* Memory Friendly: Uses the PowerShell pipeline to process events one-by-one instead of loading them all into a variable.
* Precise Filtering: Allows you to filter by values that are normally "hidden" inside the message field.

---

## 5. Advanced XPath Filtering (FilterXml)

*Use Case: Performing complex logical operations (AND/OR) on EventData fields at the provider level. Essential for high-volume logs where FilterHashtable's simple key-value matching is insufficient.*

### Multi-Condition Template
```powershell
# Define the XPath query as a Here-String
$XPathQuery = @"
<QueryList>
  <Query Id="0">
    <Select Path="<LOG_NAME>">
      *[System[(EventID=<EVENT_ID>)]] 
      and (
        *[EventData[Data='<VALUE_1>']] 
        or 
        *[EventData[Data='<VALUE_2>']]
      )
    </Select>
  </Query>
</QueryList>
"@

# Execute the search
Get-WinEvent -FilterXml $XPathQuery | ForEach-Object {
    # Custom output formatting
    Write-Host "--- Event Detected ---"
    Write-Host $_.Message "`n"
}
```
**Key Benefits:**
* Server-Side OR Logic: FilterHashtable cannot handle OR conditions for data fields. XPath allows you to look for multiple Indicators of Compromise (IOCs) in a single pass.
* Extreme Precision: By filtering inside the EventData array before the data hits your memory, you drastically reduce the processing overhead on your hunting workstation.

### Specific Attribute Filtering
```powershell
$Log = 'Microsoft-Windows-Sysmon/Operational'
$XPath = "*[EventData[Data[@Name='Image']='<PROCESS_PATH>']] and *[EventData[Data[@Name='CommandLine']='<EXACT_COMMAND_LINE>']]"

Get-WinEvent -LogName $Log -FilterXPath $XPath | 
Select-Object TimeCreated, Id, Message | 
Format-Table -AutoSize
```
---

## 6. Query Selection Guide (Decision Matrix)

| Method | Key Parameter | Best For | Performance | Logic Level |
| :--- | :--- | :--- | :--- | :--- |
| **Basic Filtering** | `-FilterHashtable` | Initial triage by ID, Time, or Level. | **Highest** | Low |
| **Precise Hunting** | `-FilterXPath` | Exact match for command lines or image paths. | **High** | Medium |
| **Complex TTPs** | `-FilterXml` | Advanced logic (OR/AND) within EventData. | **High** | **Highest** |
| **Deep Analysis** | `ForEach + [xml]` | Data extraction for CSV/Reporting or Pivoting. | Medium | **Highest** |

**The Golden Rule:**
1. Use **FilterHashtable** for metadata (Who, When, What ID).
2. Use **XPath/Xml** for content (What DLL, What Command, What IP) in noisy logs.
3. Use **XML Parsing** only after narrowing down the result set to a manageable size.

---

## 7. GUI & Output Formatting

*Helpers for visualization.*

### Interactive Grid View

```powershell
<QUERY_COMMAND> | Select-Object TimeCreated, Id, LevelDisplayName, Message | Out-GridView
```

### Export to CSV

```powershell
<QUERY_COMMAND> | Select-Object * | Export-Csv "<OUTPUT_PATH>.csv" -NoTypeInformation
```
