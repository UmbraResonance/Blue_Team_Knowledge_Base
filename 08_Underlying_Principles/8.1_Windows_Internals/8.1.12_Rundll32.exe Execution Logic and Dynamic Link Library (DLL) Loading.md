# Rundll32 Execution & DLL Loading Logic

> **Core Principle**: `rundll32.exe` is a legitimate Windows host process designed to execute specific functions exported from DLL files. It acts as a wrapper that bridge the gap between a command-line interface and dynamic libraries.
> **Blue Team Impact**: Mastering `rundll32` internals is essential for identifying **System Binary Proxy Execution (T1218.011)** and detecting sophisticated DLL Side-loading attacks that bypass standard security filters.

---

## 1. Command Line Parsing & Execution Flow
Unlike standard executables that start at `main()`, `rundll32.exe` relies on specific command-line arguments to locate and invoke code.

### 1.1 The Parser Logic
The utility follows a strict parsing sequence: `rundll32.exe <DLLPath>,<ExportName> [Arguments]`
* **Delimiter Quirk**: The parser searches for the first comma to split the DLL path from the function name. Whitespace around the comma is often permitted by the parser but can be used to obfuscate the command from simple string-matching EDR rules.
* **Ordinal Loading**: In addition to named functions, `rundll32` supports calling exports by their ordinal number (e.g., `malware.dll,#1`). This technique is frequently used by adversaries to hide intent, as the function name is not visible in the command-line logs.

### 1.2 Function Signature Requirement
For a function to be executed successfully, it must match the expected callback signature:
`void CALLBACK EntryPoint(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);`
If the signature is mismatched, the process may crash, though many malicious DLLs execute their payload within `DllMain` immediately upon loading, rendering the specific export call secondary.

## 2. DLL Loading Principles
`rundll32.exe` utilizes the standard Windows Loader (`ntdll.dll!LdrLoadDll`) to map libraries into its address space.

### 2.1 The Loading Sequence
1.  **Process Creation**: `rundll32.exe` starts as a trusted, Microsoft-signed process.
2.  **Library Mapping**: The process calls `LoadLibraryExW` on the specified DLL path.
3.  **Telemetry**: This action triggers a **Sysmon Event ID 7 (Image Load)**. Hunters should verify if the `ImageLoaded` path is a standard system directory or a suspicious location like `C:\ProgramData\`.
4.  **Verification**: Windows checks the Authenticode signature of the loaded DLL. A common red flag is a signed `rundll32.exe` loading an unsigned or context-mismatched DLL.

### 2.2 Memory Residency
Once loaded, the DLL resides in the virtual memory of `rundll32.exe`. Unlike **Manual Mapping**, which results in "unbacked" memory regions, standard loading via `rundll32` creates a clear file-to-memory mapping visible to forensic tools.

## 3. Adversarial Abuse: Proxying & Side-loading
Adversaries leverage the trusted status of `rundll32.exe` to proxy malicious execution.

* **DLL Side-loading**: Attackers place a legitimate "white" executable and a malicious DLL (renamed to a required dependency) in the same directory. Due to the DLL Search Order, the executable loads the malicious local DLL instead of the system version.
* **Execution Proxying**: By using `rundll32.exe` to run a malicious DLL, the adversary ensures that the primary process-level telemetry shows a trusted Microsoft binary, potentially bypassing "Known-Good" process whitelists.

## 4. Detection & Hunting Heuristics
* **Path Anomalies**: Monitor for `rundll32.exe` loading DLLs from writable user directories (e.g., `AppData`, `Temp`, `Public`) rather than `System32` or `Program Files`.
* **Signature Mismatches**: Use Sysmon Event ID 7 to identify instances where `rundll32.exe` (Signed) loads a DLL that is `Signed = false` or has a `SignatureStatus` of `Unavailable`.
* **Metadata Discrepancies**: Check for loaded DLLs where the `OriginalFileName` does not match the actual file name on disk, a common indicator of renamed malicious payloads.
* **Network Behavior**: `rundll32.exe` initiating network connections (Sysmon Event ID 3) to external IP